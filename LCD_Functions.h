#include "mcc_generated_files/mcc.h"

/* Pin definitions:
Most of these pins can be moved to any digital or analog pin.
DN(MOSI)and SCLK should be left where they are (SPI pins). The
LED (backlight) pin should remain on a PWM-capable pin. */
/*const int scePin = 7;   // SCE - Chip select, pin 3 on LCD.
const int rstPin = 6;   // RST - Reset, pin 4 on LCD.
const int dcPin = 5;    // DC - Data/Command, pin 5 on LCD.
const int sdinPin = 11;  // DN(MOSI) - Serial data, pin 6 on LCD.
const int sclkPin = 13;  // SCLK - Serial clock, pin 7 on LCD.
const int blPin = 9;    // LED - Backlight LED, pin 8 on LCD.
*/
/* PCD8544-specific defines: */
#define LCD_COMMAND  0
#define LCD_DATA     1
#define PI  22/7

/* 84x48 LCD Defines: */
#define LCD_WIDTH   84 // Note: x-coordinates go wide
#define LCD_HEIGHT  48 // Note: y-coordinates go high
#define WHITE       0  // For drawing pixels. A 0 draws white.
#define BLACK       1  // A 1 draws black.
/* Display control 0 0 0 0 1 D 0 E
 *  sets display configuration
*/
#define display_blank 0x08
#define normal_mode   0x0C
#define segments_on   0x09
#define inverse_video 0x0D

/* Font table:
This table contains the hex values that represent pixels for a
font that is 5 pixels wide and 8 pixels high. Each byte in a row
represents one, 8-pixel, vertical column of a character. 5 bytes
per character. */
static const uint8_t ASCII[][5]  = {
  // First 32 characters (0x00-0x19) are ignored. These are
  // non-displayable, control characters.
   {0x00, 0x00, 0x00, 0x00, 0x00} // 0x20
  ,{0x00, 0x00, 0x5f, 0x00, 0x00} // 0x21 !
  ,{0x00, 0x07, 0x00, 0x07, 0x00} // 0x22 "
  ,{0x14, 0x7f, 0x14, 0x7f, 0x14} // 0x23 #
  ,{0x24, 0x2a, 0x7f, 0x2a, 0x12} // 0x24 $
  ,{0x23, 0x13, 0x08, 0x64, 0x62} // 0x25 %
  ,{0x36, 0x49, 0x55, 0x22, 0x50} // 0x26 &
  ,{0x00, 0x05, 0x03, 0x00, 0x00} // 0x27 '
  ,{0x00, 0x1c, 0x22, 0x41, 0x00} // 0x28 (
  ,{0x00, 0x41, 0x22, 0x1c, 0x00} // 0x29 )
  ,{0x14, 0x08, 0x3e, 0x08, 0x14} // 0x2a *
  ,{0x08, 0x08, 0x3e, 0x08, 0x08} // 0x2b +
  ,{0x00, 0x50, 0x30, 0x00, 0x00} // 0x2c ,
  ,{0x08, 0x08, 0x08, 0x08, 0x08} // 0x2d -
  ,{0x00, 0x60, 0x60, 0x00, 0x00} // 0x2e .
  ,{0x20, 0x10, 0x08, 0x04, 0x02} // 0x2f /
  ,{0x3e, 0x51, 0x49, 0x45, 0x3e} // 0x30 0
  ,{0x00, 0x42, 0x7f, 0x40, 0x00} // 0x31 1
  ,{0x42, 0x61, 0x51, 0x49, 0x46} // 0x32 2
  ,{0x21, 0x41, 0x45, 0x4b, 0x31} // 0x33 3
  ,{0x18, 0x14, 0x12, 0x7f, 0x10} // 0x34 4
  ,{0x27, 0x45, 0x45, 0x45, 0x39} // 0x35 5
  ,{0x3c, 0x4a, 0x49, 0x49, 0x30} // 0x36 6
  ,{0x01, 0x71, 0x09, 0x05, 0x03} // 0x37 7
  ,{0x36, 0x49, 0x49, 0x49, 0x36} // 0x38 8
  ,{0x06, 0x49, 0x49, 0x29, 0x1e} // 0x39 9
  ,{0x00, 0x36, 0x36, 0x00, 0x00} // 0x3a :
  ,{0x00, 0x56, 0x36, 0x00, 0x00} // 0x3b ;
  ,{0x08, 0x14, 0x22, 0x41, 0x00} // 0x3c <
  ,{0x14, 0x14, 0x14, 0x14, 0x14} // 0x3d =
  ,{0x00, 0x41, 0x22, 0x14, 0x08} // 0x3e >
  ,{0x02, 0x01, 0x51, 0x09, 0x06} // 0x3f ?
  ,{0x32, 0x49, 0x79, 0x41, 0x3e} // 0x40 @
  ,{0x7e, 0x11, 0x11, 0x11, 0x7e} // 0x41 A
  ,{0x7f, 0x49, 0x49, 0x49, 0x36} // 0x42 B
  ,{0x3e, 0x41, 0x41, 0x41, 0x22} // 0x43 C
  ,{0x7f, 0x41, 0x41, 0x22, 0x1c} // 0x44 D
  ,{0x7f, 0x49, 0x49, 0x49, 0x41} // 0x45 E
  ,{0x7f, 0x09, 0x09, 0x09, 0x01} // 0x46 F
  ,{0x3e, 0x41, 0x49, 0x49, 0x7a} // 0x47 G
  ,{0x7f, 0x08, 0x08, 0x08, 0x7f} // 0x48 H
  ,{0x00, 0x41, 0x7f, 0x41, 0x00} // 0x49 I
  ,{0x20, 0x40, 0x41, 0x3f, 0x01} // 0x4a J
  ,{0x7f, 0x08, 0x14, 0x22, 0x41} // 0x4b K
  ,{0x7f, 0x40, 0x40, 0x40, 0x40} // 0x4c L
  ,{0x7f, 0x02, 0x0c, 0x02, 0x7f} // 0x4d M
  ,{0x7f, 0x04, 0x08, 0x10, 0x7f} // 0x4e N
  ,{0x3e, 0x41, 0x41, 0x41, 0x3e} // 0x4f O
  ,{0x7f, 0x09, 0x09, 0x09, 0x06} // 0x50 P
  ,{0x3e, 0x41, 0x51, 0x21, 0x5e} // 0x51 Q
  ,{0x7f, 0x09, 0x19, 0x29, 0x46} // 0x52 R
  ,{0x46, 0x49, 0x49, 0x49, 0x31} // 0x53 S
  ,{0x01, 0x01, 0x7f, 0x01, 0x01} // 0x54 T
  ,{0x3f, 0x40, 0x40, 0x40, 0x3f} // 0x55 U
  ,{0x1f, 0x20, 0x40, 0x20, 0x1f} // 0x56 V
  ,{0x3f, 0x40, 0x38, 0x40, 0x3f} // 0x57 W
  ,{0x63, 0x14, 0x08, 0x14, 0x63} // 0x58 X
  ,{0x07, 0x08, 0x70, 0x08, 0x07} // 0x59 Y
  ,{0x61, 0x51, 0x49, 0x45, 0x43} // 0x5a Z
  ,{0x00, 0x7f, 0x41, 0x41, 0x00} // 0x5b [
  ,{0x02, 0x04, 0x08, 0x10, 0x20} // 0x5c \ (keep this to escape the backslash)
  ,{0x00, 0x41, 0x41, 0x7f, 0x00} // 0x5d ]
  ,{0x04, 0x02, 0x01, 0x02, 0x04} // 0x5e ^
  ,{0x40, 0x40, 0x40, 0x40, 0x40} // 0x5f _
  ,{0x00, 0x01, 0x02, 0x04, 0x00} // 0x60 `
  ,{0x20, 0x54, 0x54, 0x54, 0x78} // 0x61 a
  ,{0x7f, 0x48, 0x44, 0x44, 0x38} // 0x62 b
  ,{0x38, 0x44, 0x44, 0x44, 0x20} // 0x63 c
  ,{0x38, 0x44, 0x44, 0x48, 0x7f} // 0x64 d
  ,{0x38, 0x54, 0x54, 0x54, 0x18} // 0x65 e
  ,{0x08, 0x7e, 0x09, 0x01, 0x02} // 0x66 f
  ,{0x0c, 0x52, 0x52, 0x52, 0x3e} // 0x67 g
  ,{0x7f, 0x08, 0x04, 0x04, 0x78} // 0x68 h
  ,{0x00, 0x44, 0x7d, 0x40, 0x00} // 0x69 i
  ,{0x20, 0x40, 0x44, 0x3d, 0x00} // 0x6a j
  ,{0x7f, 0x10, 0x28, 0x44, 0x00} // 0x6b k
  ,{0x00, 0x41, 0x7f, 0x40, 0x00} // 0x6c l
  ,{0x7c, 0x04, 0x18, 0x04, 0x78} // 0x6d m
  ,{0x7c, 0x08, 0x04, 0x04, 0x78} // 0x6e n
  ,{0x38, 0x44, 0x44, 0x44, 0x38} // 0x6f o
  ,{0x7c, 0x14, 0x14, 0x14, 0x08} // 0x70 p
  ,{0x08, 0x14, 0x14, 0x18, 0x7c} // 0x71 q
  ,{0x7c, 0x08, 0x04, 0x04, 0x08} // 0x72 r
  ,{0x48, 0x54, 0x54, 0x54, 0x20} // 0x73 s
  ,{0x04, 0x3f, 0x44, 0x40, 0x20} // 0x74 t
  ,{0x3c, 0x40, 0x40, 0x20, 0x7c} // 0x75 u
  ,{0x1c, 0x20, 0x40, 0x20, 0x1c} // 0x76 v
  ,{0x3c, 0x40, 0x30, 0x40, 0x3c} // 0x77 w
  ,{0x44, 0x28, 0x10, 0x28, 0x44} // 0x78 x
  ,{0x0c, 0x50, 0x50, 0x50, 0x3c} // 0x79 y
  ,{0x44, 0x64, 0x54, 0x4c, 0x44} // 0x7a z
  ,{0x00, 0x08, 0x36, 0x41, 0x00} // 0x7b {
  ,{0x00, 0x00, 0x7f, 0x00, 0x00} // 0x7c |
  ,{0x00, 0x41, 0x36, 0x08, 0x00} // 0x7d }
  ,{0x10, 0x08, 0x08, 0x10, 0x08} // 0x7e ~
  ,{0x78, 0x46, 0x41, 0x46, 0x78} // 0x7f DEL
};

/* The displayMap variable stores a buffer representation of the
pixels on our display. There are 504 total bits in this array,
same as how many pixels there are on a 84 x 48 display.

Each byte in this array covers a 8-pixel vertical block on the
display. Each successive byte covers the next 8-pixel column over
until you reach the right-edge of the display and step down 8 rows.

To update the display, we first have to write to this array, then
call the updateDisplay() function, which sends this whole array
to the PCD8544.

Because the PCD8544 won't let us write individual pixels at a
time, this is how we can make targeted changes to the display. */
uint8_t displayMap[LCD_WIDTH * LCD_HEIGHT / 8] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,0)->(11,7) ~ These 12 bytes cover an 8x12 block in the left corner of the display
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,0)->(23,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, // (24,0)->(35,7)
  0xF0, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFE, 0xFE, 0x1E, 0x0E, 0x02, 0x00, // (36,0)->(47,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,0)->(59,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,0)->(71,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,0)->(83,7)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,8)->(11,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,8)->(23,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, // (24,8)->(35,15)
  0x0F, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFC, 0xF8, // (36,8)->(47,15)
  0xF8, 0xF0, 0xF8, 0xFE, 0xFE, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00, // (48,8)->(59,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,8)->(71,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,8)->(83,15)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,16)->(11,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,16)->(23,23)
  0x00, 0x00, 0xF8, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF, 0xF3, 0xE0, 0xE0, 0xC0, // (24,16)->(35,23)
  0xC0, 0xC0, 0xE0, 0xE0, 0xF1, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,16)->(47,23)
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3E, 0x00, 0x00, 0x00, // (48,16)->(59,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,16)->(71,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,16)->(83,23)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,24)->(11,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,24)->(23,31)
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (24,24)->(35,31)
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, // (36,24)->(47,31)
  0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x07, 0x01, 0x00, 0x00, 0x00, 0x00, // (48,24)->(59,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,24)->(71,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,24)->(83,31)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,32)->(11,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,32)->(23,39)
  0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, // (24,32)->(35,39)
  0x0F, 0x0F, 0x0F, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x03, 0x03, // (36,32)->(47,39)
  0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,32)->(59,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,32)->(71,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,32)->(83,39)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (0,40)->(11,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (12,40)->(23,47)
  0x00, 0x00, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, // (24,40)->(35,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (36,40)->(47,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (48,40)->(59,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (60,40)->(71,47)
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // (72,40)->(83,47) !!! The bottom right pixel!
};

// There are two memory banks in the LCD, data/RAM and commands.
// This function sets the DC pin high or low depending, and then
// sends the data uint8_t
void LCDWrite(bool data_or_command, uint8_t data)
{
  //Tell the LCD that we are writing either to data or a command
  //dcPin LATDbits.LATD3 = 
  LATDbits.LATD5 = data_or_command;

  //Send the data
//  scePin_SetLow();
  SPI_write8bit(data); //shiftOut(sdinPin, sclkPin, MSBFIRST, data);
//  scePin_SetHigh();
}


// This function sets a pixel on displayMap to your preferred
// color. 1=Black, 0= white.
void setPixel(int x, int y, bool bw)
{
  // First, double check that the coordinate is in range.
  if ((x >= 0) && (x < LCD_WIDTH) && (y >= 0) && (y < LCD_HEIGHT))
  {
    uint8_t shift = y % 8;

    if (bw) // If black, set the bit.
      displayMap[x + (y/8)*LCD_WIDTH] |= 1<<shift;
    else   // If white clear the bit.
      displayMap[x + (y/8)*LCD_WIDTH] &= ~(1<<shift);
  }
}

// Because I keep forgetting to put bw variable in when setting...
void blackPixel(int x, int y)
{
  setPixel(x, y, BLACK); // Call setPixel with bw set to Black
}

void clearPixel(int x, int y)
{
  setPixel(x, y, WHITE); // call setPixel with bw set to white
}

// setLine draws a line from x0,y0 to x1,y1 with the set color.
// This function was grabbed from the SparkFun ColorLCDShield
// library.
void setLine(int x0, int y0, int x1, int y1, bool bw)
{
  int dy = y1 - y0; // Difference between y0 and y1
  int dx = x1 - x0; // Difference between x0 and x1
  int stepx, stepy;

  if (dy < 0)
  {
    dy = -dy;
    stepy = -1;
  }
  else
    stepy = 1;

  if (dx < 0)
  {
    dx = -dx;
    stepx = -1;
  }
  else
    stepx = 1;

  dy <<= 1; // dy is now 2*dy
  dx <<= 1; // dx is now 2*dx
  setPixel(x0, y0, bw); // Draw the first pixel.

  if (dx > dy)
  {
    int fraction = dy - (dx >> 1);
    while (x0 != x1)
    {
      if (fraction >= 0)
      {
        y0 += stepy;
        fraction -= dx;
      }
      x0 += stepx;
      fraction += dy;
      setPixel(x0, y0, bw);
    }
  }
  else
  {
    int fraction = dx - (dy >> 1);
    while (y0 != y1)
    {
      if (fraction >= 0)
      {
        x0 += stepx;
        fraction -= dy;
      }
      y0 += stepy;
      fraction += dx;
      setPixel(x0, y0, bw);
    }
  }
}

// setRect will draw a rectangle from x0,y0 top-left corner to
// a x1,y1 bottom-right corner. Can be filled with the fill
// parameter, and colored with bw.
// This function was grabbed from the SparkFun ColorLCDShield
// library.
void setRect(int x0, int y0, int x1, int y1, bool fill, bool bw)
{
  // check if the rectangle is to be filled
  if (fill == 1)
  {
    int xDiff;

    if(x0 > x1)
      xDiff = x0 - x1; //Find the difference between the x vars
    else
      xDiff = x1 - x0;

    while(xDiff > 0)
    {
      setLine(x0, y0, x0, y1, bw);

      if(x0 > x1)
        x0--;
      else
        x0++;

      xDiff--;
    }
  }
  else
  {
    // best way to draw an unfilled rectangle is to draw four lines
    setLine(x0, y0, x1, y0, bw);
    setLine(x0, y1, x1, y1, bw);
    setLine(x0, y0, x0, y1, bw);
    setLine(x1, y0, x1, y1, bw);
  }
}

// setCircle draws a circle centered around x0,y0 with a defined
// radius. The circle can be black or white. And have a line
// thickness ranging from 1 to the radius of the circle.
// This function was grabbed from the SparkFun ColorLCDShield
// library.
void setCircle (int x0, int y0, int radius, bool bw, int lineThickness)
{
  for(int r = 0; r < lineThickness; r++)
  {
    int f = 1 - radius;
    int ddF_x = 0;
    int ddF_y = -2 * radius;
    int x = 0;
    int y = radius;

    setPixel(x0, y0 + radius, bw);
    setPixel(x0, y0 - radius, bw);
    setPixel(x0 + radius, y0, bw);
    setPixel(x0 - radius, y0, bw);

    while(x < y)
    {
      if(f >= 0)
      {
        y--;
        ddF_y += 2;
        f += ddF_y;
      }
      x++;
      ddF_x += 2;
      f += ddF_x + 1;

      setPixel(x0 + x, y0 + y, bw);
      setPixel(x0 - x, y0 + y, bw);
      setPixel(x0 + x, y0 - y, bw);
      setPixel(x0 - x, y0 - y, bw);
      setPixel(x0 + y, y0 + x, bw);
      setPixel(x0 - y, y0 + x, bw);
      setPixel(x0 + y, y0 - x, bw);
      setPixel(x0 - y, y0 - x, bw);
    }
    radius--;
  }
}

// This function will draw a char (defined in the ASCII table
// near the beginning of this sketch) at a defined x and y).
// The color can be either black (1) or white (0).
void setChar(char character, int x, int y, bool bw)
{
  uint8_t column; // temp byte to store character's column bitmap
  for (int i=0; i<5; i++) // 5 columns (x) per character
  {
    column = ASCII[character - 0x20][i];
    for (int j=0; j<8; j++) // 8 rows (y) per character
    {
      if (column & (0x01 << j)) // test bits to set pixels
        setPixel(x+i, y+j, bw);
      else
        setPixel(x+i, y+j, !bw);
    }
  }
}

// setStr draws a string of characters, calling setChar with
// progressive coordinates until it's done.
// This function was grabbed from the SparkFun ColorLCDShield
// library.
void setStr(char * dString, int x, int y, bool bw)
{
  while (*dString != 0x00) // loop until null terminator
  {
    setChar(*dString++, x, y, bw);
    x+=5;
    for (int i=y; i<y+8; i++)
    {
      setPixel(x, i, !bw);
    }
    x++;
    if (x > (LCD_WIDTH - 5)) // Enables wrap around
    {
      x = 0;
      y += 8;
    }
  }
}

// This function will draw an array over the screen. (For now) the
// array must be the same size as the screen, covering the entirety
// of the display.
// Also, the array must reside in FLASH and declared with .
void setBitmap(const char * bitArray)
{
  for (int i=0; i<(LCD_WIDTH * LCD_HEIGHT / 8); i++)
  {
    uint8_t c = bitArray[i];
    displayMap[i] = c;
  }
}

// This function clears the entire display either white (0) or
// black (1).
// The screen won't actually clear until you call updateDisplay()!
void clearDisplay(bool bw)
{
  for (int i=0; i<(LCD_WIDTH * LCD_HEIGHT / 8); i++)
  {
    if (bw)
      displayMap[i] = 0xFF;
    else
      displayMap[i] = 0;
  }
}

// Helpful function to directly command the LCD to go to a
// specific x,y coordinate.
void gotoXY(int x, int y)
{
  LCDWrite(0, 0x80 | x);  // Column.
  LCDWrite(0, 0x40 | y);  // Row.  ?
}

// This will actually draw on the display, whatever is currently
// in the displayMap array.
void updateDisplay()
{
  gotoXY(0, 0);
  for (int i=0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++)
  {
    LCDWrite(LCD_DATA, displayMap[i]);
  }
}

// Set contrast can set the LCD Vop to a value between 0 and 127.
// 40-60 is usually a pretty good range.
void setContrast(uint8_t contrast)
{
  LCDWrite(LCD_COMMAND, 0x21); //Tell LCD that extended commands follow
  LCDWrite(LCD_COMMAND, 0x80 | contrast); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  LCDWrite(LCD_COMMAND, 0x20); //Set display mode
}

/* There are two ways to do this. Either through direct commands
to the display, or by swapping each bit in the displayMap array.
We'll leave both methods here, comment one or the other out if
you please. */
void invertDisplay()
{
  /* Direct LCD Command option
  LCDWrite(LCD_COMMAND, 0x20); //Tell LCD that extended commands follow
  LCDWrite(LCD_COMMAND, 0x08 | 0x05); //Set LCD Vop (Contrast): Try 0xB1(good @ 3.3V) or 0xBF if your display is too dark
  LCDWrite(LCD_COMMAND, 0x20); //Set display mode  */

  /* Indirect, swap bits in displayMap option: */
  for (int i=0; i < (LCD_WIDTH * LCD_HEIGHT / 8); i++)
  {
    displayMap[i] = ~displayMap[i] & 0xFF;
  }
  updateDisplay();
}
/*
 9.4.1 Command Write Mode sitronix
The write mode of the interface means the micro controller writes commands and data to the LCD driver.
3-lines serial data packet contains a control bit D/CX and a transmission byte. In 4-lines serial interface, data
packet contains just transmission byte and control bit D/CX is transferred by the D/CX pin. If D/CX is ?low?,
the transmission byte is interpreted as a command byte. If D/CX is ?high?, the transmission byte is stored in
the display data RAM (memory write command), or command register as parameter.
Any instruction can be sent in any order to the driver. The MSB is transmitted first. The serial interface is
initialized when CSX is high. In this state, SCL clock pulse or SDA data have no effect. A falling edge on CSX
enables the serial interface and indicates the start of data transmission.*/

//This sends the magical commands to the PCD8544
void lcdBegin(void)
{
  /*Configure control pins
  pinMode(scePin, OUTPUT);
  pinMode(rstPin, OUTPUT);
  pinMode(dcPin, OUTPUT);
  pinMode(sdinPin, OUTPUT);
  pinMode(sclkPin, OUTPUT);
  pinMode(blPin, OUTPUT);
  analogWrite(blPin, 255);

  SPI.begin();
  SPI.setDataMode(SPI_MODE0);
  SPI.setBitOrder(MSBFIRST);
*/
  //Reset the LCD to a known state
  rstPin_SetHigh();
  DelayMs(10); //add a 10mSec delay
  rstPin_SetLow();
  DelayMs(10); //add a 10mSec delay
  rstPin_SetHigh();
  scePin_SetLow();
  LCDWrite(LCD_COMMAND, 0x21); //Tell LCD extended commands follow
  LCDWrite(LCD_COMMAND, 0xB0); //Set LCD Vop (Contrast)
  LCDWrite(LCD_COMMAND, 0x04); //Set Temp coefficent
  LCDWrite(LCD_COMMAND, 0x14); //LCD bias mode 1:48 (try 0x13)
  //We must send 0x20 before modifying the display control mode
  LCDWrite(LCD_COMMAND, 0x20);
  LCDWrite(LCD_COMMAND, normal_mode); //Set display control, normal mode.
  Graphic_test();
  scePin_SetLow();
  LCDWrite(LCD_COMMAND, 0x20);
  LCDWrite(LCD_COMMAND, segments_on); //Set display control, normal mode.
  scePin_SetHigh();
}

void DelayMs(int delay)
{
    TMR5_Initialize() ;
    T5CONbits.ON = 1;
    while( delay )
    {
        if(IFS0bits.T5IF)
        {
            delay--;
            IFS0bits.T5IF = 0;
            TMR5_Initialize() ;
            T5CONbits.ON = 1;
        } 
    }
    // mCTClearIntFlag();
}


void SPI_write8bit(uint8_t data);
void LCDWrite(bool data_or_command, uint8_t data);
void DelayMs(int delay);
//void setPixel(int x, int y);
/*void	digitalWrite(uint8_t pin, uint8_t val)
{
    
}*/
void SPI_write8bit(uint8_t data)
{
    while( SPI1STATbits.SPITBF == true )
    {

    }

    SPI1BUF = data;
    if (SPI1STATbits.SPIRBE == false)
    {
        data = SPI1BUF;
    }
        
    while( SPI1STATbits.SRMT == false )
    {

    }

}

//Ported from display.h
static int fontpos = 0;
static int ypos = 0;
static int pagepos = 0;


//These define my fonts ascii codes on the right
static const uint8_t font_fixed_8px_data[] = {
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x00
0x00,0x3E,0x45,0x51,0x45,0x3E,	// 0x01 6
0x00,0x3E,0x6B,0x6F,0x6B,0x3E,	// 0x02 12
0x00,0x1C,0x3E,0x7C,0x3E,0x1C,	// 0x03 18
0x00,0x18,0x3C,0x7E,0x3C,0x18,	// 0x04
0x00,0x30,0x36,0x7F,0x36,0x30,	// 0x05
0x00,0x18,0x5C,0x7E,0x5C,0x18,	// 0x06
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x07
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x08
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x09
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x0A
0x00,0x30,0x48,0x4A,0x36,0x0E,	// 0x0B
0x00,0x06,0x29,0x79,0x29,0x06,	// 0x0C
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x0D
0x00,0x60,0x7E,0x0A,0x35,0x3F,	// 0x0E
0x00,0x2A,0x1C,0x36,0x1C,0x2A,	// 0x0F
0x00,0x00,0x7F,0x3E,0x1C,0x08,	// 0x10
0x00,0x08,0x1C,0x3E,0x7F,0x00,	// 0x11
0x00,0x14,0x36,0x7F,0x36,0x14,	// 0x12
0x00,0x00,0x5F,0x00,0x5F,0x00,	// 0x13
0x00,0x06,0x09,0x7F,0x01,0x7F,	// 0x14
0x00,0x22,0x4D,0x55,0x59,0x22,	// 0x15
0x00,0x60,0x60,0x60,0x60,0x00,	// 0x16
0x00,0x14,0xB6,0xFF,0xB6,0x14,	// 0x17
0x00,0x04,0x06,0x7F,0x06,0x04,	// 0x18
0x00,0x10,0x30,0x7F,0x30,0x10,	// 0x19
0x00,0x08,0x08,0x3E,0x1C,0x08,	// 0x1A
0x00,0x08,0x1C,0x3E,0x08,0x08,	// 0x1B
0x00,0x78,0x40,0x40,0x40,0x40,	// 0x1C
0x00,0x08,0x3E,0x08,0x3E,0x08,	// 0x1D
0x00,0x30,0x3C,0x3F,0x3C,0x30,	// 0x1E
0x00,0x03,0x0F,0x3F,0x0F,0x03,	// 0x1F
0x00,0x00,0x00,0x00,0x00,0x00,	// 0x20
0x00,0x00,0x06,0x5F,0x06,0x00,	// 0x21
0x00,0x07,0x03,0x00,0x07,0x03,	// 0x22
0x00,0x24,0x7E,0x24,0x7E,0x24,	// 0x23
0x00,0x24,0x2B,0x6A,0x12,0x00,	// 0x24
0x00,0x63,0x13,0x08,0x64,0x63,	// 0x25
0x00,0x36,0x49,0x56,0x20,0x50,	// 0x26
0x00,0x00,0x07,0x03,0x00,0x00,	// 0x27
0x00,0x00,0x3E,0x41,0x00,0x00,	// 0x28
0x00,0x00,0x41,0x3E,0x00,0x00,	// 0x29
0x00,0x08,0x3E,0x1C,0x3E,0x08,	// 0x2A
0x00,0x08,0x08,0x3E,0x08,0x08,	// 0x2B
0x00,0x00,0xE0,0x60,0x00,0x00,	// 0x2C
0x00,0x08,0x08,0x08,0x08,0x08,	// 0x2D
0x00,0x00,0x60,0x60,0x00,0x00,	// 0x2E
0x00,0x20,0x10,0x08,0x04,0x02,	// 0x2F
0x00,0x3E,0x51,0x49,0x45,0x3E,	// 0x30
0x00,0x00,0x42,0x7F,0x40,0x00,	// 0x31
0x00,0x62,0x51,0x49,0x49,0x46,	// 0x32
0x00,0x22,0x49,0x49,0x49,0x36,	// 0x33
0x00,0x18,0x14,0x12,0x7F,0x10,	// 0x34
0x00,0x2F,0x49,0x49,0x49,0x31,	// 0x35
0x00,0x3C,0x4A,0x49,0x49,0x30,	// 0x36
0x00,0x01,0x71,0x09,0x05,0x03,	// 0x37
0x00,0x36,0x49,0x49,0x49,0x36,	// 0x38
0x00,0x06,0x49,0x49,0x29,0x1E,	// 0x39
0x00,0x00,0x6C,0x6C,0x00,0x00,	// 0x3A
0x00,0x00,0xEC,0x6C,0x00,0x00,	// 0x3B
0x00,0x08,0x14,0x22,0x41,0x00,	// 0x3C
0x00,0x24,0x24,0x24,0x24,0x24,	// 0x3D
0x00,0x00,0x41,0x22,0x14,0x08,	// 0x3E
0x00,0x02,0x01,0x59,0x09,0x06,	// 0x3F
0x00,0x3E,0x41,0x5D,0x55,0x1E,	// 0x40
0x00,0x7E,0x11,0x11,0x11,0x7E,	// 0x41
0x00,0x7F,0x49,0x49,0x49,0x36,	// 0x42
0x00,0x3E,0x41,0x41,0x41,0x22,	// 0x43
0x00,0x7F,0x41,0x41,0x41,0x3E,	// 0x44
0x00,0x7F,0x49,0x49,0x49,0x41,	// 0x45
0x00,0x7F,0x09,0x09,0x09,0x01,	// 0x46
0x00,0x3E,0x41,0x49,0x49,0x7A,	// 0x47
0x00,0x7F,0x08,0x08,0x08,0x7F,	// 0x48
0x00,0x00,0x41,0x7F,0x41,0x00,	// 0x49
0x00,0x30,0x40,0x40,0x40,0x3F,	// 0x4A
0x00,0x7F,0x08,0x14,0x22,0x41,	// 0x4B
0x00,0x7F,0x40,0x40,0x40,0x40,	// 0x4C
0x00,0x7F,0x02,0x04,0x02,0x7F,	// 0x4D
0x00,0x7F,0x02,0x04,0x08,0x7F,	// 0x4E
0x00,0x3E,0x41,0x41,0x41,0x3E,	// 0x4F
0x00,0x7F,0x09,0x09,0x09,0x06,	// 0x50
0x00,0x3E,0x41,0x51,0x21,0x5E,	// 0x51
0x00,0x7F,0x09,0x09,0x19,0x66,	// 0x52
0x00,0x26,0x49,0x49,0x49,0x32,	// 0x53
0x00,0x01,0x01,0x7F,0x01,0x01,	// 0x54
0x00,0x3F,0x40,0x40,0x40,0x3F,	// 0x55
0x00,0x1F,0x20,0x40,0x20,0x1F,	// 0x56
0x00,0x3F,0x40,0x3C,0x40,0x3F,	// 0x57
0x00,0x63,0x14,0x08,0x14,0x63,	// 0x58
0x00,0x07,0x08,0x70,0x08,0x07,	// 0x59
0x00,0x71,0x49,0x45,0x43,0x00,	// 0x5A
0x00,0x00,0x7F,0x41,0x41,0x00,	// 0x5B
0x00,0x02,0x04,0x08,0x10,0x20,	// 0x5C
0x00,0x00,0x41,0x41,0x7F,0x00,	// 0x5D
0x00,0x04,0x02,0x01,0x02,0x04,	// 0x5E
0x80,0x80,0x80,0x80,0x80,0x80,	// 0x5F
0x00,0x00,0x03,0x07,0x00,0x00,	// 0x60
0x00,0x20,0x54,0x54,0x54,0x78,	// 0x61
0x00,0x7F,0x44,0x44,0x44,0x38,	// 0x62
0x00,0x38,0x44,0x44,0x44,0x28,	// 0x63
0x00,0x38,0x44,0x44,0x44,0x7F,	// 0x64
0x00,0x38,0x54,0x54,0x54,0x08,	// 0x65
0x00,0x08,0x7E,0x09,0x09,0x00,	// 0x66
0x00,0x18,0xA4,0xA4,0xA4,0x7C,	// 0x67
0x00,0x7F,0x04,0x04,0x78,0x00,	// 0x68
0x00,0x00,0x00,0x7D,0x40,0x00,	// 0x69
0x00,0x40,0x80,0x84,0x7D,0x00,	// 0x6A
0x00,0x7F,0x10,0x28,0x44,0x00,	// 0x6B
0x00,0x00,0x00,0x7F,0x40,0x00,	// 0x6C
0x00,0x7C,0x04,0x18,0x04,0x78,	// 0x6D
0x00,0x7C,0x04,0x04,0x78,0x00,	// 0x6E
0x00,0x38,0x44,0x44,0x44,0x38,	// 0x6F
0x00,0xFC,0x44,0x44,0x44,0x38,	// 0x70
0x00,0x38,0x44,0x44,0x44,0xFC,	// 0x71
0x00,0x44,0x78,0x44,0x04,0x08,	// 0x72
0x00,0x08,0x54,0x54,0x54,0x20,	// 0x73
0x00,0x04,0x3E,0x44,0x24,0x00,	// 0x74
0x00,0x3C,0x40,0x20,0x7C,0x00,	// 0x75
0x00,0x1C,0x20,0x40,0x20,0x1C,	// 0x76
0x00,0x3C,0x60,0x30,0x60,0x3C,	// 0x77
0x00,0x6C,0x10,0x10,0x6C,0x00,	// 0x78
0x00,0x9C,0xA0,0x60,0x3C,0x00,	// 0x79
0x00,0x64,0x54,0x54,0x4C,0x00,	// 0x7A
0x00,0x08,0x3E,0x41,0x41,0x00,	// 0x7B
0x00,0x00,0x00,0x77,0x00,0x00,	// 0x7C
0x00,0x00,0x41,0x41,0x3E,0x08,	// 0x7D
0x00,0x02,0x01,0x02,0x01,0x00,	// 0x7E
0x00,0x3C,0x26,0x23,0x26,0x3C,	// 0x7F
0x00,0x1E,0xA1,0xE1,0x21,0x12,	// 0x80
0x00,0x3D,0x40,0x20,0x7D,0x00,	// 0x81
0x00,0x38,0x54,0x54,0x55,0x09,	// 0x82
0x00,0x20,0x55,0x55,0x55,0x78,	// 0x83
0x00,0x20,0x55,0x54,0x55,0x78,	// 0x84
0x00,0x20,0x55,0x55,0x54,0x78,	// 0x85
0x00,0x20,0x57,0x55,0x57,0x78,	// 0x86
0x00,0x1C,0xA2,0xE2,0x22,0x14,	// 0x87
0x00,0x38,0x55,0x55,0x55,0x08,	// 0x88
0x00,0x38,0x55,0x54,0x55,0x08,	// 0x89
0x00,0x38,0x55,0x55,0x54,0x08,	// 0x8A
0x00,0x00,0x01,0x7C,0x41,0x00,	// 0x8B
0x00,0x00,0x01,0x7D,0x41,0x00,	// 0x8C
0x00,0x00,0x01,0x7C,0x40,0x00,	// 0x8D
0x00,0x70,0x29,0x24,0x29,0x70,	// 0x8E
0x00,0x78,0x2F,0x25,0x2F,0x78,	// 0x8F
0x00,0x7C,0x54,0x54,0x55,0x45,	// 0x90
0x00,0x34,0x54,0x7C,0x54,0x58,	// 0x91
0x00,0x7E,0x09,0x7F,0x49,0x49,	// 0x92
0x00,0x38,0x45,0x45,0x39,0x00,	// 0x93
0x00,0x38,0x45,0x44,0x39,0x00,	// 0x94
0x00,0x39,0x45,0x44,0x38,0x00,	// 0x95
0x00,0x3C,0x41,0x21,0x7D,0x00,	// 0x96
0x00,0x3D,0x41,0x20,0x7C,0x00,	// 0x97
0x00,0x9C,0xA1,0x60,0x3D,0x00,	// 0x98
0x00,0x3D,0x42,0x42,0x3D,0x00,	// 0x99
0x00,0x3C,0x41,0x40,0x3D,0x00,	// 0x9A
0x80,0x70,0x68,0x58,0x38,0x04,	// 0x9B
0x00,0x48,0x3E,0x49,0x49,0x62,	// 0x9C
0x00,0x7E,0x61,0x5D,0x43,0x3F,	// 0x9D
0x00,0x22,0x14,0x08,0x14,0x22,	// 0x9E
0x00,0x40,0x88,0x7E,0x09,0x02,	// 0x9F
0x00,0x20,0x54,0x55,0x55,0x78,	// 0xA0
0x00,0x00,0x00,0x7D,0x41,0x00,	// 0xA1
0x00,0x38,0x44,0x45,0x39,0x00,	// 0xA2
0x00,0x3C,0x40,0x21,0x7D,0x00,	// 0xA3
0x00,0x7A,0x09,0x0A,0x71,0x00,	// 0xA4
0x00,0x7A,0x11,0x22,0x79,0x00,	// 0xA5
0x00,0x08,0x55,0x55,0x55,0x5E,	// 0xA6
0x00,0x4E,0x51,0x51,0x4E,0x00,	// 0xA7
0x00,0x30,0x48,0x4D,0x40,0x20,	// 0xA8
0x3E,0x41,0x5D,0x4B,0x55,0x3E,	// 0xA9
0x04,0x04,0x04,0x04,0x04,0x1C,	// 0xAA
0x00,0x17,0x08,0x4C,0x6A,0x50,	// 0xAB
0x00,0x17,0x08,0x34,0x2A,0x78,	// 0xAC
0x00,0x00,0x30,0x7D,0x30,0x00,	// 0xAD
0x00,0x08,0x14,0x00,0x08,0x14,	// 0xAE
0x00,0x14,0x08,0x00,0x14,0x08,	// 0xAF
0x44,0x11,0x44,0x11,0x44,0x11,	// 0xB0
0xAA,0x55,0xAA,0x55,0xAA,0x55,	// 0xB1
0xBB,0xEE,0xBB,0xEE,0xBB,0xEE,	// 0xB2
0x00,0x00,0x00,0xFF,0x00,0x00,	// 0xB3
0x08,0x08,0x08,0xFF,0x00,0x00,	// 0xB4
0x00,0x70,0x28,0x25,0x29,0x70,	// 0xB5
0x00,0x70,0x29,0x25,0x29,0x70,	// 0xB6
0x00,0x70,0x29,0x25,0x28,0x70,	// 0xB7
0x3E,0x41,0x5D,0x55,0x41,0x3E,	// 0xB8
0x0A,0xFB,0x00,0xFF,0x00,0x00,	// 0xB9
0x00,0xFF,0x00,0xFF,0x00,0x00,	// 0xBA
0x0A,0xFA,0x02,0xFE,0x00,0x00,	// 0xBB
0x0A,0x0B,0x08,0x0F,0x00,0x00,	// 0xBC
0x00,0x18,0x24,0x66,0x24,0x00,	// 0xBD
0x00,0x29,0x2A,0x7C,0x2A,0x29,	// 0xBE
0x08,0x08,0x08,0xF8,0x00,0x00,	// 0xBF
0x00,0x00,0x00,0x0F,0x08,0x08,	// 0xC0
0x08,0x08,0x08,0x0F,0x08,0x08,	// 0xC1
0x08,0x08,0x08,0xF8,0x08,0x08,	// 0xC2
0x00,0x00,0x00,0xFF,0x08,0x08,	// 0xC3
0x08,0x08,0x08,0x08,0x08,0x08,	// 0xC4
0x08,0x08,0x08,0xFF,0x08,0x08,	// 0xC5
0x00,0x20,0x56,0x55,0x56,0x79,	// 0xC6
0x00,0x70,0x2A,0x25,0x2A,0x71,	// 0xC7
0x00,0x0F,0x08,0x0B,0x0A,0x0A,	// 0xC8
0x00,0xFE,0x02,0xFA,0x0A,0x0A,	// 0xC9
0x0A,0x0B,0x08,0x0B,0x0A,0x0A,	// 0xCA
0x0A,0xFA,0x02,0xFA,0x0A,0x0A,	// 0xCB
0x00,0xFF,0x00,0xFB,0x0A,0x0A,	// 0xCC
0x0A,0x0A,0x0A,0x0A,0x0A,0x0A,	// 0xCD
0x0A,0xFB,0x00,0xFB,0x0A,0x0A,	// 0xCE
0x00,0x5D,0x22,0x22,0x22,0x5D,	// 0xCF
0x00,0x22,0x55,0x59,0x30,0x00,	// 0xD0
0x00,0x08,0x7F,0x49,0x41,0x3E,	// 0xD1
0x00,0x7C,0x55,0x55,0x55,0x44,	// 0xD2
0x00,0x7C,0x55,0x54,0x55,0x44,	// 0xD3
0x00,0x7C,0x55,0x55,0x54,0x44,	// 0xD4
0x00,0x00,0x00,0x07,0x00,0x00,	// 0xD5
0x00,0x00,0x44,0x7D,0x45,0x00,	// 0xD6
0x00,0x00,0x45,0x7D,0x45,0x00,	// 0xD7
0x00,0x00,0x45,0x7C,0x45,0x00,	// 0xD8
0x08,0x08,0x08,0x0F,0x00,0x00,	// 0xD9
0x00,0x00,0x00,0xF8,0x08,0x08,	// 0xDA
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,	// 0xDB
0xF0,0xF0,0xF0,0xF0,0xF0,0xF0,	// 0xDC
0x00,0x00,0x00,0x77,0x00,0x00,	// 0xDD
0x00,0x00,0x45,0x7D,0x44,0x00,	// 0xDE
0x0F,0x0F,0x0F,0x0F,0x0F,0x0F,	// 0xDF
0x00,0x3C,0x42,0x43,0x3D,0x00,	// 0xE0
0x00,0xFE,0x4A,0x4A,0x34,0x00,	// 0xE1
0x00,0x3C,0x43,0x43,0x3D,0x00,	// 0xE2
0x00,0x3D,0x43,0x42,0x3C,0x00,	// 0xE3
0x00,0x32,0x49,0x4A,0x31,0x00,	// 0xE4
0x00,0x3A,0x45,0x46,0x39,0x00,	// 0xE5
0x00,0xFC,0x20,0x20,0x1C,0x00,	// 0xE6
0x00,0xFE,0xAA,0x28,0x10,0x00,	// 0xE7
0x00,0xFF,0xA5,0x24,0x18,0x00,	// 0xE8
0x00,0x3C,0x40,0x41,0x3D,0x00,	// 0xE9
0x00,0x3C,0x41,0x41,0x3D,0x00,	// 0xEA
0x00,0x3D,0x41,0x40,0x3C,0x00,	// 0xEB
0x00,0x9C,0xA0,0x61,0x3D,0x00,	// 0xEC
0x00,0x04,0x08,0x71,0x09,0x04,	// 0xED
0x00,0x00,0x02,0x02,0x02,0x00,	// 0xEE
0x00,0x00,0x07,0x03,0x00,0x00,	// 0xEF
0x00,0x00,0x08,0x08,0x08,0x00,	// 0xF0
0x00,0x00,0x24,0x2E,0x24,0x00,	// 0xF1
0x00,0x24,0x24,0x24,0x24,0x24,	// 0xF2
0x05,0x17,0x0A,0x34,0x2A,0x78,	// 0xF3
0x00,0x06,0x09,0x7F,0x01,0x7F,	// 0xF4
0x00,0x22,0x4D,0x55,0x59,0x22,	// 0xF5
0x00,0x08,0x08,0x2A,0x08,0x08,	// 0xF6
0x00,0x00,0x08,0x18,0x18,0x00,	// 0xF7
0x00,0x06,0x09,0x09,0x06,0x00,	// 0xF8
0x00,0x00,0x08,0x00,0x08,0x00,	// 0xF9
0x00,0x00,0x08,0x00,0x00,0x00,	// 0xFA
0x00,0x02,0x0F,0x00,0x00,0x00,	// 0xFB
0x00,0x09,0x0F,0x05,0x00,0x00,	// 0xFC
0x00,0x09,0x0D,0x0A,0x00,0x00,	// 0xFD
0x00,0x3C,0x3C,0x3C,0x3C,0x00,	// 0xFE
0x00,0x00,0x00,0x00,0x00,0x00 	// 0xFF
};

/*Copyright Dave Plater 24 February 2020
 display.c interface with 84x48 monochrome graphics display
 * The display has 128 columns by 8 x 8 bit pages (64)
 * ie column 0 to 0x7F and page 0 to 7, MSB is at top and
 * LSB is at the bottom
*/
//#include "gsm.h"

//Lower and upper 4 bit column addresses added to 0x01 for upper and 0x0 for lower
//Sets the starting point on one of eight lines
//Numbered from 0 to 136 with 8 x 8 bytes per font including spaces
uint8_t column[2];

void Set_Column(uint8_t col)
{
    uint8_t i = col & 0x0F;
    column[0] = i;
    column[1] = (col >> 4) & 0x0F | 0x10;
    dcPin_SetLow();
    SPI_write8bit(column[1]);
    SPI_write8bit(column[0]);
    dcPin_SetHigh();
}

//One page = one of 8 lines
void Set_Page(uint8_t gpage)
{
    gpage = (gpage & 0x0F);
    gpage = (gpage | 0xB0);
    dcPin_SetLow();
    SPI_write8bit(gpage);
    dcPin_SetHigh();
    
}
//Start from the beginning of "line"
void Set_Line(uint8_t line)
{
    dcPin_SetLow();
    //Send 0x40 Display start line 0
    SPI_write8bit( 0x40 );
    Set_Column(0);
    Set_Page(line);
}

void Clr_Line(void)
{
     for(uint8_t x = 0; x < 137; x++)
     {
         Write_Font(0);
     }
}

void Write_String(uint8_t *lcdstring, uint8_t lcdline)
{
    LATDbits.LATD3 = 0; //Select display
    //Send 0x40 Display start line 0
    dcPin_SetLow();
    SPI_write8bit( 0x40 );
    Set_Line(lcdline);
    Clr_Line();
    Set_Line(lcdline);
    ypos = 0;
    uint8_t x = 0;
    uint8_t i = lcdstring[x];
    while((ypos < 137) && (i != 0))
    {
        i = lcdstring[x++];
        Write_Font(i);
    }
    LATDbits.LATD3 = 1; //Deselect display
}
//Write where Write_String left off
void Continue_String(uint8_t *clcdstring)
{
    LATDbits.LATD3 = 0; //Select display
    uint8_t x = 0;
    uint8_t i = clcdstring[x];
    while((ypos < 137) && (i != 0))
    {
        i = clcdstring[x++];
        Write_Font(i);
    }
    LATDbits.LATD3 = 1; //Deselect display    
}
//static int ypos and static int pagepos
//Write 5 font data bytes to display
void Write_Font(uint8_t _font)
{
    fontpos = _font * 6;
    dcPin_SetHigh();
    for(int i = 0; i < 6; i++ )
    {
        SPI_write8bit(font_fixed_8px_data[fontpos+i]);
    }
    SPI_write8bit(0); //Empty space after font
    ypos = ypos + 8; // 0 t0 17 characters = 18, ypos end =136
}

void Graphic_test(void)
{
    uint8_t x = 0;
    ypos = 0;
    fontpos = 0;
    pagepos = 0;
    uint8_t character = 0x2F;
    scePin_SetLow();
    dcPin_SetLow(); //LATDbit 5
  //void LCDWrite(bool data_or_command, uint8_t data)
    gotoXY(0, 0); //set start line to 0
    while(pagepos <= 7)
    {
        Set_Page(pagepos++);
        Set_Column(ypos);
        while(ypos < LCD_WIDTH - 1) //The last character ends at 84
        {
            if (character >= 0x80)
            {
                character = 0x2F;
            }
            Write_Font(character++);
            fontpos = fontpos + 6; //3 = 0x132
        }
        ypos = 0;
    }
//    Graphic_Clear();
//    Write_String(clocktime, 1);
//    Write_String(clockdate, 6);
    
    scePin_SetHigh(); //Deselect display
    __asm__("NOP");
}




